package com.dreamsecurity.ca.business.cert.service;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.SignatureException;
import java.security.cert.CertPathBuilderException;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import javax.xml.bind.DatatypeConverter;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.dreamsecurity.ca.business.cert.common.CertConstants;
import com.dreamsecurity.ca.business.cert.dao.CertDao;
import com.dreamsecurity.ca.business.cert.vo.CertVo;
import com.dreamsecurity.ca.business.cert.vo.KeyVo;
import com.dreamsecurity.ca.business.common.CommonConstants;
import com.dreamsecurity.ca.business.login.common.LoginConstants;
import com.dreamsecurity.ca.framework.cert.CaCertGenerator;
import com.dreamsecurity.ca.framework.cert.CertGeneratorFactory;
import com.dreamsecurity.ca.framework.cert.KmsTrustManagerFactory;
import com.dreamsecurity.ca.framework.cert.RootCertGenerator;
import com.dreamsecurity.ca.framework.cert.UserCertGenerator;
import com.dreamsecurity.ca.framework.init.CaSettings;
import com.dreamsecurity.ca.framework.utils.CaUtils;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import sun.security.x509.KeyIdentifier;

@Service
public class CertService {
	
	@Resource
	private CertDao certDao;
	
	private KeyPairGenerator keyPairGenerator;
	
	public String downloadCertFile( int certId, HttpServletRequest request ) throws IOException {
		CertVo vo = new CertVo();
		vo.setId( certId );
		vo = certDao.selectCertBinary( vo );
				
		return DatatypeConverter.printBase64Binary( vo.getFile() );
	}
	
	public boolean verifyCertificate( byte[] cert ) throws CertificateException, NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, CertPathBuilderException {
		CertificateFactory certFactory = CertificateFactory.getInstance( "X.509" );
		X509Certificate eeCert = (X509Certificate) certFactory.generateCertificate( new ByteArrayInputStream( cert ) );
		
		
		CertVo eeVo = new CertVo();
		List<CertVo> rootInterVoList = null;
		
		eeVo.setSubjectDn( eeCert.getSubjectDN().getName().getBytes() );
		
		eeVo = certDao.selectCertInfoOneUsingDN( eeVo );
		
		if ( eeVo != null ) {
			rootInterVoList = certDao.selectRootInterCertUsingOuType( eeVo );
		} else {
			// throw Exception 없음요
			System.out.println( " throw exception 처리 해야함 null 요맨" );
		}
		
		Set<X509Certificate> certChain = new HashSet<>();
		for ( int i=0; i<rootInterVoList.size(); i++ ) {
			certChain.add( (X509Certificate) certFactory.generateCertificate( new ByteArrayInputStream( rootInterVoList.get( i ).getFile() ) ) ) ;
		}
		
		KmsTrustManagerFactory.verifyCertificate( eeCert, certChain, false );
		
		return true;
	}
	
	public List<Map<String, Object>> showList( HttpServletRequest request ) {
		List<Map<String,Object>> voMapList = certDao.selectCertList();
		
		for ( Map<String, Object> voMap : voMapList ) {
			voMap.put( "subjectdn", new String( (byte[]) voMap.get( "subjectdn" ) ) );
			voMap.put( "enddate", CommonConstants.dateFormat.format( (Date)voMap.get( "enddate" ) ) );
			voMap.put( "startdate", CommonConstants.dateFormat.format( (Date)voMap.get( "startdate" ) ) );
		}
		
		return voMapList;
	}
	
	public CertVo mappingObject( HttpServletRequest request ) throws JsonParseException, JsonMappingException, IOException {
		ObjectMapper mapper = new ObjectMapper();
		String body = null;
		
		if ( request.getAttribute( "body" ) != null ) {
			body = request.getAttribute( "body" ).toString();
		}
		
		return mapper.readValue( body, CertVo.class );
	}
	
	@Transactional(rollbackFor={Exception.class})
	public void register( HttpServletRequest request, CertVo vo ) throws InvalidKeyException, CertificateException, NoSuchAlgorithmException, NoSuchProviderException, SignatureException, IllegalAccessException, IOException, InvalidKeySpecException {
		HttpSession session = request.getSession();
		vo.setSubject( session.getAttribute( LoginConstants.SESSION_ID ).toString() );
		
		keyPairGenerator = KeyPairGenerator.getInstance( CertConstants.KEY_ALGORITHM );
		keyPairGenerator.initialize( 2048 );
		
		if ( vo.getType() == 0 && session.getAttribute( LoginConstants.SESSION_AUTH ).equals( 0 ) ) {
			this.registerRootCa( vo );
		} else if ( vo.getType() == 1 && session.getAttribute( LoginConstants.SESSION_AUTH ).equals( 1 ) ) {
			this.registerIntermediateCa( vo );
		} else if ( vo.getType() == 2 && session.getAttribute( LoginConstants.SESSION_AUTH ).equals( 1 ) ) {
			this.registerEeCert( vo );
		} else {
			throw new IllegalArgumentException( "Certificate Type has wrong value." );
		}
	}
	
	private X509Certificate registerRootCa( CertVo certVo ) throws InvalidKeyException, CertificateException, NoSuchAlgorithmException, NoSuchProviderException, SignatureException, IOException, IllegalAccessException {
		KeyPair rootKeyPair = keyPairGenerator.generateKeyPair();
		String dn = new StringBuilder().append( "CN = " ).append( CaSettings.getInstance().get( "rootCaCn" ) )
				.append( " OU = " ).append( CaSettings.getInstance().get( "rootCaOrganizationUnit" ) )
				.append( " O = " ).append( CaSettings.getInstance().get( "organization" ) )
				.append( " C = " ).append( CaSettings.getInstance().get( "country" ) ).toString();
		
		if ( !certDao.hasRootCa() ) {
			throw new IllegalAccessException( "Server already has RootCA.");
		}
		
		BigInteger serialNumber = BigInteger.valueOf( certDao.selectCertSerialNumber( certVo ) + 1);
		
		X509Certificate rootCert = CertGeneratorFactory.building()
				.subject( rootKeyPair )
				.validity( certVo.getValidity() )
				.algorithm( CertConstants.CERT_ALGORITHM )
				.issuer( rootKeyPair.getPrivate() )
				.dn( dn )
				.serialNumber( serialNumber )
				.type( RootCertGenerator.class )
				.build()
				.generateCertificate();
	 	
		certVo.setIssuer( certVo.getSubject() );
		certVo = setKeyAndCertVo( certVo, rootKeyPair, serialNumber, rootCert );
		
		certDao.insertKeyInfo( certVo.getKeyVo() );
		certVo.setKeyId( certVo.getKeyVo().getId() );
		certDao.insertCertInfo( certVo );

		return rootCert;
	}
	
	private X509Certificate registerIntermediateCa( CertVo certVo ) throws InvalidKeyException, CertificateException, NoSuchAlgorithmException, NoSuchProviderException, SignatureException, IOException, InvalidKeySpecException, IllegalAccessException {
		KeyPair caKeyPair = keyPairGenerator.generateKeyPair();
		String dn = new StringBuilder().append( "CN = " ).append( CaSettings.getInstance().get( "intermediateCaCn" ) )
				.append( " OU = " ).append( certVo.getOuType() )
				.append( " O = " ).append( CaSettings.getInstance().get( "organization" ) )
				.append( " C = " ).append( CaSettings.getInstance().get( "country" ) ).toString();
		
		if ( !certDao.hasIntermediateCa( certVo ) ) {
			throw new IllegalAccessException( "Server already has IntermediateCA, OU: " + certVo.getOuType() );
		}
		
		CertVo rootCaVo = certDao.selectRootCertAndKeyInfoOne(); 
		
		if ( rootCaVo == null ) 
			throw new IllegalAccessException( "RootCA is not found");
		
		certVo.setIssuer( rootCaVo.getSubject() );
		X509Certificate rootCert = CaUtils.bytesToX509Cert( rootCaVo.getFile() );
		PrivateKey rootPriKey = CaUtils.pkcs8bytesToPrivateKeyObj( rootCaVo.getKeyVo().getPrivateKey() );
		BigInteger serialNumber = BigInteger.valueOf( certDao.selectCertSerialNumber( certVo ) + 1);
		
		X509Certificate intermediateCa = CertGeneratorFactory.building()
				.subject( caKeyPair )
				.validity( certVo.getValidity() )
				.algorithm( CertConstants.CERT_ALGORITHM )
				.issuer( rootPriKey )
				.issuerCert( rootCert )
				.dn( dn )
				.serialNumber( serialNumber )
				.type( CaCertGenerator.class )
				.build()
				.generateCertificate();
		
		certVo.setIssuer( rootCaVo.getSubject() );
		certVo = setKeyAndCertVo( certVo, caKeyPair, serialNumber, intermediateCa );
		
		certDao.insertKeyInfo( certVo.getKeyVo() );
		certVo.setKeyId( certVo.getKeyVo().getId() );
		certDao.insertCertInfo( certVo );
		
		return intermediateCa;
	}
	
	
	private X509Certificate registerEeCert( CertVo certVo ) throws NoSuchAlgorithmException, InvalidKeySpecException, CertificateException, InvalidKeyException, NoSuchProviderException, SignatureException, IOException, IllegalAccessException {
		KeyPair eeCertKeyPair = keyPairGenerator.generateKeyPair();
		String dn = new StringBuilder().append( "CN = " ).append(certVo.getCiteName() )
				.append( " OU = " ).append( certVo.getOuType() )
				.append( " O = " ).append( CaSettings.getInstance().get( "organization" ) )
				.append( " C = " ).append( CaSettings.getInstance().get( "country" ) ).toString();
		
		CertVo intermediateCaVo = certDao.selectIntermediateCertAndKeyInfoOne( certVo ); 
		
		if ( intermediateCaVo == null ) {
			throw new IllegalAccessException( certVo.getOuType() + " 's IntermediateCa is not found." ); 
		}
		
		certVo.setIssuer( intermediateCaVo.getSubject() );
		X509Certificate ca = CaUtils.bytesToX509Cert( intermediateCaVo.getFile() );
		PrivateKey caPriKey = CaUtils.pkcs8bytesToPrivateKeyObj( intermediateCaVo.getKeyVo().getPrivateKey() );
		BigInteger serialNumber = BigInteger.valueOf( certDao.selectCertSerialNumber( certVo ) + 1);
		
		X509Certificate eeCert = CertGeneratorFactory.building()
				.subject( eeCertKeyPair )
				.validity( certVo.getValidity() )
				.algorithm( CertConstants.CERT_ALGORITHM )
				.issuer( caPriKey )
				.issuerCert( ca )
				.dn( dn )
				.serialNumber( serialNumber )
//				.subjectAltName( dnsName )
				.type( UserCertGenerator.class )
				.build()
				.generateCertificate();
		
		certVo.setIssuer( intermediateCaVo.getSubject() );
		certVo = setKeyAndCertVo( certVo, eeCertKeyPair, serialNumber, eeCert );
		
		certDao.insertKeyInfo( certVo.getKeyVo() );
		certVo.setKeyId( certVo.getKeyVo().getId() );
		certDao.insertCertInfo( certVo );
		
		return eeCert;
	}
	

	private CertVo setKeyAndCertVo( CertVo certVo, KeyPair keyPair, BigInteger serialNumber, X509Certificate cert ) throws CertificateEncodingException, IOException {
		KeyVo keyVo = setKeyVo( new KeyVo(), keyPair, cert );
		
		certVo.setSerialNumber( serialNumber.intValue() );
		certVo.setFile( cert.getEncoded() );
		certVo.setIssuingRequestDate( new Date() );
		certVo.setStartDate( cert.getNotBefore() );
		certVo.setEndDate( cert.getNotAfter() );
		certVo.setSubjectDn( cert.getSubjectDN().getName().getBytes() );
		certVo.setKeyVo( keyVo );
		
		return certVo;
	}
	
	private KeyVo setKeyVo( KeyVo vo, KeyPair keyPair, X509Certificate cert ) throws IOException {
		vo.setPrivateKey( keyPair.getPrivate().getEncoded() );
		vo.setPublicKey( keyPair.getPublic().getEncoded() );
		vo.setPublicKeyIdentifier( new KeyIdentifier( cert.getPublicKey() ).getIdentifier() );
		
		return vo;
	}
}	
